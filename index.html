<!doctype html>
<html lang="zh-Hant">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>2026 樺專用刮刮樂</title>
    <style>
        :root {
            --card-w: min(92vw, 520px);
            --card-h: var(--card-w);
            --gold-1: #ffe7a8;
        }

        body {
            margin: 0;
            font-family: "Noto Serif TC", "PMingLiU", "Microsoft JhengHei", serif;
            background:
                radial-gradient(circle at 15% 20%, rgba(255, 225, 120, .22), transparent 32%),
                radial-gradient(circle at 84% 18%, rgba(255, 189, 95, .18), transparent 28%),
                radial-gradient(circle at 50% 110%, rgba(255, 120, 90, .32), transparent 35%),
                linear-gradient(150deg, #5f0007 0%, #8f070d 38%, #b11514 100%);
            color: #fff5e6;
            display: grid;
            place-items: center;
            min-height: 100vh;
            padding: 22px 14px 28px;
            box-sizing: border-box;
        }

        .wrap {
            width: min(96vw, 640px);
            text-align: center;
        }

        .hero-year {
            margin: 0;
            color: var(--gold-1);
            font-weight: 900;
            font-size: clamp(30px, 7.4vw, 48px);
            letter-spacing: .08em;
            text-shadow: 0 3px 0 rgba(78, 12, 1, .72), 0 12px 28px rgba(0, 0, 0, .35);
        }

        h1 {
            margin: 6px 0 12px;
            font-size: clamp(28px, 6.8vw, 44px);
            font-weight: 900;
            line-height: 1.15;
            color: #fff7d4;
            text-shadow: 0 3px 0 rgba(89, 13, 4, .8), 0 10px 24px rgba(0, 0, 0, .35);
        }

        .hint {
            color: #fff0ca;
            font-size: 15px;
            margin-bottom: 12px;
            line-height: 1.5;
        }

        .card {
            position: relative;
            width: var(--card-w);
            height: var(--card-h);
            border-radius: 22px;
            overflow: hidden;
            background: linear-gradient(140deg, #9e0f10, #b21616 55%, #870d0d);
            box-shadow: 0 18px 50px rgba(21, 2, 1, .44), 0 0 0 3px rgba(255, 208, 110, .42);
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
            margin: 0 auto;
        }

        .card::before {
            content: "";
            position: absolute;
            inset: 0;
            border: 3px solid rgba(255, 226, 154, .5);
            pointer-events: none;
            border-radius: inherit;
            z-index: 3;
        }

        .card.jackpot {
            animation: jackpot-card-glow 0.9s ease-in-out infinite alternate;
        }

        .card.jackpot::before {
            border-color: rgba(255, 236, 167, .98);
            box-shadow:
                0 0 14px rgba(255, 211, 90, .95),
                0 0 34px rgba(255, 176, 50, .76),
                inset 0 0 14px rgba(255, 240, 185, .52);
            animation: jackpot-border-blink 0.34s steps(2, end) infinite;
        }

        @keyframes jackpot-card-glow {
            0% {
                box-shadow: 0 18px 50px rgba(21, 2, 1, .44), 0 0 0 3px rgba(255, 208, 110, .42);
            }

            100% {
                box-shadow:
                    0 18px 50px rgba(21, 2, 1, .44),
                    0 0 0 4px rgba(255, 229, 138, .96),
                    0 0 24px rgba(255, 199, 68, .85),
                    0 0 52px rgba(255, 151, 20, .58);
            }
        }

        @keyframes jackpot-border-blink {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: .58;
            }
        }

        @media (prefers-reduced-motion: reduce) {
            .card.jackpot {
                animation: none;
            }

            .card.jackpot::before {
                animation: none;
            }
        }

        .prize-layer {
            position: absolute;
            inset: 0;
            display: grid;
            place-items: center;
            padding: 30px 28px;
            text-align: center;
            background:
                radial-gradient(circle at 30% 20%, rgba(255, 247, 194, .25), transparent 35%),
                linear-gradient(150deg, #b20f14 0%, #d9301c 46%, #a90f11 100%);
            z-index: 1;
        }

        .prize-title {
            font-size: 15px;
            color: #ffecba;
            letter-spacing: .08em;
        }

        .prize {
            margin-top: 10px;
            font-size: clamp(28px, 7vw, 38px);
            font-weight: 900;
            line-height: 1.15;
            color: #fff7d8;
            text-shadow: 0 2px 0 rgba(95, 5, 4, .75);
        }

        .sub {
            margin-top: 10px;
            font-size: 15px;
            color: #ffe8b3;
        }

        canvas#scratch {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            display: block;
            z-index: 2;
        }

        .controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 14px;
            flex-wrap: wrap;
        }

        button {
            border: 0;
            border-radius: 12px;
            padding: 11px 16px;
            background: linear-gradient(135deg, #ffda82, #ffbe3f);
            color: #5d0c05;
            font-weight: 700;
            cursor: pointer;
            box-shadow: 0 4px 0 rgba(135, 65, 0, .52);
        }

        button.secondary {
            background: linear-gradient(135deg, #ffd6a2, #ffab75);
            color: #5f1207;
        }

        button:active {
            transform: translateY(1px);
        }

        button:disabled {
            opacity: .5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .status {
            text-align: center;
            margin-top: 12px;
            font-size: 14px;
            color: #fff3d3;
            min-height: 1.2em;
        }

        .badge {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 999px;
            background: rgba(255, 237, 168, .18);
            margin-left: 6px;
            font-size: 12px;
            color: #fff8df;
        }

        .blessing {
            margin-top: 10px;
            font-size: 16px;
            color: #ffe7b8;
            font-weight: 700;
            letter-spacing: .05em;
            text-shadow: 0 2px 8px rgba(0, 0, 0, .3);
        }

        .summary-modal {
            position: fixed;
            inset: 0;
            z-index: 1200;
            display: none;
            align-items: center;
            justify-items: center;
            background:
                radial-gradient(circle at 20% 15%, rgba(255, 217, 120, .24), transparent 34%),
                radial-gradient(circle at 80% 85%, rgba(255, 183, 96, .22), transparent 32%),
                rgba(28, 2, 2, .68);
            backdrop-filter: blur(2px);
            padding: 18px;
            box-sizing: border-box;
        }

        .summary-modal.show {
            display: grid;
        }

        .summary-card {
            width: min(92vw, 460px);
            border-radius: 20px;
            border: 2px solid rgba(255, 223, 152, .88);
            background:
                radial-gradient(circle at 15% 10%, rgba(255, 228, 149, .34), transparent 30%),
                linear-gradient(160deg, #7e0708 0%, #b21414 45%, #8a0d0d 100%);
            color: #fff5de;
            box-shadow:
                0 24px 46px rgba(0, 0, 0, .42),
                0 0 0 2px rgba(255, 204, 108, .32),
                0 0 32px rgba(255, 173, 60, .35);
            overflow: hidden;
        }

        .summary-head {
            padding: 16px 18px 10px;
            border-bottom: 1px solid rgba(255, 228, 167, .28);
            background: linear-gradient(180deg, rgba(255, 226, 147, .15), rgba(255, 226, 147, 0));
        }

        .summary-title {
            margin: 0;
            font-size: clamp(24px, 5.6vw, 30px);
            font-weight: 900;
            letter-spacing: .08em;
            color: #fff2c8;
            text-shadow: 0 2px 0 rgba(100, 12, 2, .7), 0 8px 20px rgba(0, 0, 0, .28);
        }

        .summary-sub {
            margin-top: 6px;
            font-size: 14px;
            color: #ffe7b6;
        }

        .summary-list {
            margin: 0;
            padding: 14px 18px 6px;
            list-style: none;
        }

        .summary-item {
            display: grid;
            grid-template-columns: 28px 1fr;
            gap: 10px;
            align-items: start;
            padding: 10px 0;
            border-bottom: 1px dashed rgba(255, 226, 156, .25);
        }

        .summary-item:last-child {
            border-bottom: 0;
        }

        .summary-index {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: grid;
            place-items: center;
            font-weight: 800;
            font-size: 12px;
            color: #6c1a00;
            background: linear-gradient(160deg, #ffe6a6, #ffc64f);
            box-shadow: inset 0 -1px 0 rgba(152, 90, 0, .45);
        }

        .summary-prize {
            font-size: 16px;
            font-weight: 700;
            color: #fff4d4;
        }

        .summary-note {
            margin-top: 3px;
            font-size: 13px;
            color: #ffdca6;
            opacity: .92;
        }

        .summary-actions {
            padding: 12px 18px 18px;
            display: flex;
            justify-content: center;
        }

        .summary-confirm {
            min-width: 120px;
            padding: 10px 16px;
            border-radius: 12px;
            border: 0;
            font-size: 15px;
            font-weight: 800;
            color: #651503;
            cursor: pointer;
            background: linear-gradient(160deg, #ffe5a0, #ffc445);
            box-shadow: 0 4px 0 rgba(133, 69, 0, .48);
        }

        .summary-confirm:active {
            transform: translateY(1px);
        }

        @media (max-width: 560px) {
            .prize-layer {
                padding: 24px 20px;
            }

            .prize {
                font-size: clamp(24px, 8.2vw, 34px);
            }
        }
    </style>
</head>

<body>
    <div class="wrap">
        <p class="hero-year">2026</p>
        <h1>馬力 Max 好運 Max</h1>
        <div class="hint">
            刮開新春封面，馬到成功、好運滿滿！
            <span class="badge" id="progressBadge">0%</span>
            <span class="badge" id="drawsBadge">剩餘 3 次</span>
        </div>

        <div class="card" id="card">
            <div class="prize-layer">
                <div>
                    <div class="prize-title">你抽到的獎品</div>
                    <div class="prize" id="prizeText">—</div>
                    <div class="sub" id="prizeSub">刮開才知道～</div>
                </div>
            </div>
            <canvas id="scratch"></canvas>
        </div>

        <div class="controls">
            <button id="resetBtn">再刮一張</button>
            <button class="secondary" id="revealBtn">馬上揭曉</button>
            <button class="secondary" id="hardResetBtn">重製（需密碼）</button>
            <button class="secondary" id="prizeCatalogBtn">查看獎品列表</button>
        </div>

        <div class="status" id="status"></div>
        <div class="blessing">Max Chang 祝你新年快樂 !</div>
    </div>

    <div class="summary-modal" id="summaryModal" aria-hidden="true">
        <div class="summary-card">
            <div class="summary-head">
                <h2 class="summary-title">新春刮刮樂結果</h2>
                <div class="summary-sub">恭喜完成 3 次抽獎，祝你今年好運旺旺來</div>
            </div>
            <ul class="summary-list" id="summaryList"></ul>
            <div class="summary-actions">
                <button type="button" class="summary-confirm" id="summaryConfirmBtn">確認</button>
            </div>
        </div>
    </div>

    <div class="summary-modal" id="prizeCatalogModal" aria-hidden="true">
        <div class="summary-card">
            <div class="summary-head">
                <h2 class="summary-title">全部獎品列表</h2>
                <div class="summary-sub">以下是本次刮刮樂所有可抽中的獎項</div>
            </div>
            <ul class="summary-list" id="prizeCatalogList"></ul>
            <div class="summary-actions">
                <button type="button" class="summary-confirm" id="prizeCatalogConfirmBtn">確認</button>
            </div>
        </div>
    </div>

    <script>
        const PRIZES = [
            {text: "現金 200 元", weight: 40, sub: "小確幸天天來。"},
            {text: "現金 520 元", weight: 40, sub: "我愛妳，妳也要愛我哦！。"},
            {text: "現金 666 元", weight: 25, sub: "今天運氣不錯！"},
            {text: "美甲耗材補助 1000", weight: 12, sub: "漂亮事業加碼。"},
            {text: "現金 999 元", weight: 15, sub: "好運開始發酵。"},
            {text: "現金 1314 元", weight: 10, sub: "愛妳一生一世。", jackpot: true},
            {text: "飾品任選一件（約 1200）", weight: 8, sub: "質感小心機。", jackpot: true},
            {text: "現金 1600 元", weight: 5, sub: "大獎降臨！最大包！", jackpot: true},
            {text: "服飾任選一件（約 1600）", weight: 4, sub: "直接升級穿搭。", jackpot: true},
            {text: "接睫毛費用我出", weight: 3, sub: "你的漂亮我來負責。", jackpot: true},
            {text: "Max 抱抱一次（無價）", weight: 30, sub: "限定一次，抱緊處理。"},
        ];

        function pickWeighted(items) {
            const total = items.reduce((s, it) => s + (it.weight ?? 1), 0);
            let r = Math.random() * total;
            for (const it of items) {
                r -= (it.weight ?? 1);
                if (r <= 0) return it;
            }
            return items[items.length - 1];
        }

        const canvas = document.getElementById("scratch");
        const card = document.getElementById("card");
        const prizeText = document.getElementById("prizeText");
        const prizeSub = document.getElementById("prizeSub");
        const statusEl = document.getElementById("status");
        const progressBadge = document.getElementById("progressBadge");
        const drawsBadge = document.getElementById("drawsBadge");
        const resetBtn = document.getElementById("resetBtn");
        const revealBtn = document.getElementById("revealBtn");
        const hardResetBtn = document.getElementById("hardResetBtn");
        const prizeCatalogBtn = document.getElementById("prizeCatalogBtn");
        const summaryModal = document.getElementById("summaryModal");
        const summaryList = document.getElementById("summaryList");
        const summaryConfirmBtn = document.getElementById("summaryConfirmBtn");
        const prizeCatalogModal = document.getElementById("prizeCatalogModal");
        const prizeCatalogList = document.getElementById("prizeCatalogList");
        const prizeCatalogConfirmBtn = document.getElementById("prizeCatalogConfirmBtn");

        const ctx = canvas.getContext("2d", {willReadFrequently: true});
        const COVER_IMAGE_SRC = "cover.png";

        let isDown = false;
        let revealed = false;
        let activePointerId = null;
        let lastPoint = null;
        let progressRafId = 0;
        let lastProgressCheckAt = 0;
        let coverImageReady = false;

        const SCRATCH_RADIUS = 18;
        const REVEAL_THRESHOLD = 0.65;
        const SAMPLE_STRIDE = 4;
        const PROGRESS_UPDATE_INTERVAL = 90;
        const CLEAR_ALPHA_THRESHOLD = 24;
        const MAX_CANVAS_DPR = 2;
        const MAX_DRAWS = 3;
        const RESET_PASSCODE = "0818";
        const SUMMARY_DELAY_MS = 3000;
        const ROUGH_LINE_AREA_FACTOR = 0.55;
        const ROUGH_DOT_AREA_FACTOR = 0.65;

        const coverImage = new Image();
        let canvasCssWidth = 0;
        let canvasCssHeight = 0;
        let canvasDpr = 1;
        let currentPrize = null;
        let drawCount = 0;
        let roughClearedArea = 0;
        let pixelReadFailed = false;
        let drawHistory = [];
        let summaryTimerId = 0;
        let summaryCountdownId = 0;

        coverImage.addEventListener("load", () => {
            coverImageReady = true;
            if (!revealed) drawCover();
        });
        coverImage.addEventListener("error", () => {
            coverImageReady = false;
            console.warn(`Failed to load cover image: ${COVER_IMAGE_SRC}`);
        });
        coverImage.src = COVER_IMAGE_SRC;

        function resizeCanvasToCard() {
            const rect = card.getBoundingClientRect();
            canvasCssWidth = rect.width;
            canvasCssHeight = rect.height;
            canvasDpr = Math.min(MAX_CANVAS_DPR, Math.max(1, window.devicePixelRatio || 1));

            canvas.width = Math.round(canvasCssWidth * canvasDpr);
            canvas.height = Math.round(canvasCssHeight * canvasDpr);
            canvas.style.width = canvasCssWidth + "px";
            canvas.style.height = canvasCssHeight + "px";
            ctx.setTransform(canvasDpr, 0, 0, canvasDpr, 0, 0);
        }

        function drawCover() {
            const w = canvasCssWidth || card.clientWidth;
            const h = canvasCssHeight || card.clientHeight;

            ctx.globalCompositeOperation = "source-over";
            ctx.clearRect(0, 0, w, h);

            if (coverImageReady && coverImage.naturalWidth > 0 && coverImage.naturalHeight > 0) {
                drawCoverImage(w, h);
            } else {
                drawFallbackCover(w, h);
            }

            ctx.fillStyle = "rgba(51,11,4,.38)";
            ctx.fillRect(0, h - 54, w, 54);
            ctx.fillStyle = "rgba(255,244,218,.98)";
            ctx.font = "900 16px 'Microsoft JhengHei', 'Noto Sans TC', sans-serif";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText("刮開看今年好運", w / 2, h - 27);

            ctx.globalCompositeOperation = "destination-out";
            ctx.lineCap = "round";
            ctx.lineJoin = "round";
            ctx.lineWidth = SCRATCH_RADIUS * 2;
            ctx.strokeStyle = "rgba(0,0,0,1)";
            ctx.fillStyle = "rgba(0,0,0,1)";
        }

        function clearScratchLayer() {
            const w = canvasCssWidth || card.clientWidth;
            const h = canvasCssHeight || card.clientHeight;
            ctx.globalCompositeOperation = "source-over";
            ctx.clearRect(0, 0, w, h);
        }

        function updateDrawsBadge() {
            const remaining = Math.max(0, MAX_DRAWS - drawCount);
            drawsBadge.textContent = `剩餘 ${remaining} 次`;
        }

        function updateButtons() {
            const noMoreRounds = drawCount >= MAX_DRAWS;
            resetBtn.disabled = !revealed || noMoreRounds;
            revealBtn.disabled = revealed;
        }

        function drawCoverImage(w, h) {
            const iw = coverImage.naturalWidth;
            const ih = coverImage.naturalHeight;
            const scale = Math.max(w / iw, h / ih);
            const dw = iw * scale;
            const dh = ih * scale;
            const dx = (w - dw) * 0.5;
            const dy = (h - dh) * 0.5;
            ctx.drawImage(coverImage, dx, dy, dw, dh);
        }

        function drawFallbackCover(w, h) {
            const grad = ctx.createLinearGradient(0, 0, w, h);
            grad.addColorStop(0, "#ffe29a");
            grad.addColorStop(0.55, "#ffc451");
            grad.addColorStop(1, "#d68f16");
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, w, h);

            ctx.globalAlpha = 0.2;
            ctx.fillStyle = "#8f1b06";
            for (let x = -h; x < w + h; x += 16) {
                ctx.save();
                ctx.translate(x, 0);
                ctx.rotate((24 * Math.PI) / 180);
                ctx.fillRect(0, 0, 8, h * 2);
                ctx.restore();
            }
            ctx.globalAlpha = 1;
        }

        function setPrize() {
            currentPrize = pickWeighted(PRIZES);
            prizeText.textContent = currentPrize.text;
            prizeSub.textContent = currentPrize.sub ?? "";
        }

        function showFinalSummaryPopup() {
            if (drawHistory.length === 0) return;
            summaryList.innerHTML = drawHistory
                .map(
                    (item, index) => `
                        <li class="summary-item">
                            <span class="summary-index">${index + 1}</span>
                            <div>
                                <div class="summary-prize">${item.text}</div>
                                <div class="summary-note">${item.sub || "好運加碼中"}</div>
                            </div>
                        </li>
                    `
                )
                .join("");
            summaryModal.classList.add("show");
            summaryModal.setAttribute("aria-hidden", "false");
        }

        function hideFinalSummaryPopup() {
            summaryModal.classList.remove("show");
            summaryModal.setAttribute("aria-hidden", "true");
        }

        function showPrizeCatalogPopup() {
            prizeCatalogList.innerHTML = PRIZES
                .map(
                    (item, index) => `
                        <li class="summary-item">
                            <span class="summary-index">${index + 1}</span>
                            <div>
                                <div class="summary-prize">${item.text}</div>
                                <div class="summary-note">${item.sub || "—"}（權重 ${item.weight ?? 1}${item.jackpot ? " / 大獎" : ""}）</div>
                            </div>
                        </li>
                    `
                )
                .join("");
            prizeCatalogModal.classList.add("show");
            prizeCatalogModal.setAttribute("aria-hidden", "false");
        }

        function hidePrizeCatalogPopup() {
            prizeCatalogModal.classList.remove("show");
            prizeCatalogModal.setAttribute("aria-hidden", "true");
        }

        function clearSummaryTimers() {
            if (summaryTimerId) {
                clearTimeout(summaryTimerId);
                summaryTimerId = 0;
            }
            if (summaryCountdownId) {
                clearInterval(summaryCountdownId);
                summaryCountdownId = 0;
            }
        }

        function getPointFromEvent(e) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top,
            };
        }

        function scratchDot(x, y) {
            if (revealed) return;
            ctx.beginPath();
            ctx.arc(x, y, SCRATCH_RADIUS, 0, Math.PI * 2);
            ctx.fill();
            roughClearedArea += Math.PI * SCRATCH_RADIUS * SCRATCH_RADIUS * ROUGH_DOT_AREA_FACTOR;
        }

        function scratchLine(from, to) {
            if (revealed) return;
            const dx = to.x - from.x;
            const dy = to.y - from.y;
            const distance = Math.hypot(dx, dy);

            ctx.beginPath();
            ctx.moveTo(from.x, from.y);
            ctx.lineTo(to.x, to.y);
            ctx.stroke();

            roughClearedArea += distance * (SCRATCH_RADIUS * 2) * ROUGH_LINE_AREA_FACTOR;
            scratchDot(to.x, to.y);
        }

        function estimateClearedRatio() {
            const areaBase = (canvasCssWidth || card.clientWidth) * (canvasCssHeight || card.clientHeight);
            const roughRatio = areaBase > 0 ? Math.min(1, roughClearedArea / areaBase) : 0;

            if (!canvas.width || !canvas.height || pixelReadFailed) {
                return roughRatio;
            }

            let pixelRatio = 0;
            try {
                const w = canvas.width;
                const h = canvas.height;
                const img = ctx.getImageData(0, 0, w, h).data;
                const stride = Math.max(1, Math.round(SAMPLE_STRIDE * canvasDpr));
                let total = 0;
                let cleared = 0;

                for (let y = 0; y < h; y += stride) {
                    for (let x = 0; x < w; x += stride) {
                        const i = (y * w + x) * 4 + 3;
                        total++;
                        if (img[i] <= CLEAR_ALPHA_THRESHOLD) cleared++;
                    }
                }
                pixelRatio = total > 0 ? cleared / total : 0;
            } catch (err) {
                pixelReadFailed = true;
                console.warn("Canvas pixel read blocked, fallback to rough progress estimation.", err);
            }

            return Math.max(pixelRatio, roughRatio);
        }

        function requestProgressUpdate(force = false) {
            const now = performance.now();
            if (force || now - lastProgressCheckAt >= PROGRESS_UPDATE_INTERVAL) {
                lastProgressCheckAt = now;
                updateProgress();
                return;
            }
            if (progressRafId) return;
            progressRafId = requestAnimationFrame(() => {
                progressRafId = 0;
                lastProgressCheckAt = performance.now();
                updateProgress();
            });
        }

        function updateProgress() {
            const ratio = estimateClearedRatio();
            const pct = Math.min(100, Math.max(0, Math.round(ratio * 100)));
            const pctLabel = `${pct}%`;
            if (progressBadge.textContent !== pctLabel) {
                progressBadge.textContent = pctLabel;
            }
            if (!revealed && ratio >= REVEAL_THRESHOLD) {
                revealAll("🧨 喜氣滿點，恭喜揭曉！");
            }
        }

        function revealAll(msg) {
            if (revealed) return;

            revealed = true;
            isDown = false;
            activePointerId = null;
            lastPoint = null;

            const baseRevealMsg = msg || "已揭曉";
            statusEl.textContent = baseRevealMsg;
            card.classList.toggle("jackpot", Boolean(currentPrize?.jackpot));

            if (progressRafId) {
                cancelAnimationFrame(progressRafId);
                progressRafId = 0;
            }

            clearScratchLayer();
            progressBadge.textContent = "100%";

            clearSummaryTimers();
            if (drawCount >= MAX_DRAWS) {
                let remainSec = Math.ceil(SUMMARY_DELAY_MS / 1000);
                statusEl.textContent = `${baseRevealMsg}（${remainSec} 秒後顯示總結）`;
                summaryCountdownId = setInterval(() => {
                    remainSec -= 1;
                    if (remainSec > 0) {
                        statusEl.textContent = `${baseRevealMsg}（${remainSec} 秒後顯示總結）`;
                    }
                }, 1000);
                summaryTimerId = setTimeout(() => {
                    clearSummaryTimers();
                    statusEl.textContent = `${baseRevealMsg}（已完成 3 次抽獎，請重製）`;
                    showFinalSummaryPopup();
                }, SUMMARY_DELAY_MS);
            }

            updateButtons();
        }

        function startRound() {
            clearSummaryTimers();
            hideFinalSummaryPopup();
            if (drawCount >= MAX_DRAWS) {
                statusEl.textContent = "已完成 3 次抽獎，請按「重製（需密碼）」並輸入 0818。";
                updateButtons();
                return;
            }

            drawCount++;
            roughClearedArea = 0;
            pixelReadFailed = false;
            revealed = false;
            isDown = false;
            activePointerId = null;
            lastPoint = null;
            lastProgressCheckAt = 0;

            if (progressRafId) {
                cancelAnimationFrame(progressRafId);
                progressRafId = 0;
            }

            statusEl.textContent = `第 ${drawCount} / ${MAX_DRAWS} 抽`;
            progressBadge.textContent = "0%";

            card.classList.remove("jackpot");
            setPrize();
            drawHistory.push({text: currentPrize.text, sub: currentPrize.sub ?? ""});
            resizeCanvasToCard();
            drawCover();
            updateDrawsBadge();
            updateButtons();
        }

        function hardReset() {
            clearSummaryTimers();
            const input = window.prompt("請輸入重製密碼");
            if (input === null) return;
            if (input !== RESET_PASSCODE) {
                statusEl.textContent = "密碼錯誤，無法重製。";
                return;
            }

            drawCount = 0;
            drawHistory = [];
            statusEl.textContent = "重製成功，開始新的 3 次抽獎。";
            hideFinalSummaryPopup();
            startRound();
        }

        function onPointerDown(e) {
            if (revealed || isDown) return;
            e.preventDefault();
            activePointerId = e.pointerId;
            isDown = true;
            canvas.setPointerCapture?.(e.pointerId);
            const p = getPointFromEvent(e);
            lastPoint = p;
            scratchDot(p.x, p.y);
            requestProgressUpdate(true);
        }

        function onPointerMove(e) {
            if (!isDown || e.pointerId !== activePointerId) return;
            e.preventDefault();
            const p = getPointFromEvent(e);
            if (!lastPoint) {
                lastPoint = p;
                scratchDot(p.x, p.y);
            } else {
                scratchLine(lastPoint, p);
                lastPoint = p;
            }
            requestProgressUpdate();
        }

        function onPointerUp(e) {
            if (!isDown || e.pointerId !== activePointerId) return;
            e.preventDefault();
            if (canvas.hasPointerCapture?.(e.pointerId)) {
                canvas.releasePointerCapture(e.pointerId);
            }
            isDown = false;
            activePointerId = null;
            lastPoint = null;
            requestProgressUpdate(true);
        }

        canvas.addEventListener("pointerdown", onPointerDown, {passive: false});
        canvas.addEventListener("pointermove", onPointerMove, {passive: false});
        canvas.addEventListener("pointerup", onPointerUp, {passive: false});
        canvas.addEventListener("pointercancel", onPointerUp, {passive: false});

        resetBtn.addEventListener("click", startRound);
        revealBtn.addEventListener("click", () => revealAll("🐎 直接揭曉，馬上開運！"));
        hardResetBtn.addEventListener("click", hardReset);
        prizeCatalogBtn.addEventListener("click", showPrizeCatalogPopup);
        summaryConfirmBtn.addEventListener("click", hideFinalSummaryPopup);
        prizeCatalogConfirmBtn.addEventListener("click", hidePrizeCatalogPopup);

        window.addEventListener("resize", () => {
            const wasRevealed = revealed;
            resizeCanvasToCard();
            if (!wasRevealed) drawCover();
            else clearScratchLayer();
        });

        startRound();
    </script>
</body>

</html>
